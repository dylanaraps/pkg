#!/bin/sh
# shellcheck disable=2086,2154,2123,2034,SC1007 source=/dev/null
#
# pkg - package manager for kiss linux.

pkgfile_read() {
    [ -f pkgfile ] || die "pkgfile not found"

    . pkgfile || die "syntax error in pkgfile"

    [ -z "$name" ] &&    die "name not defined in pkgfile"
    [ -z "$version" ] && die "version not defined in pkgfile"
    [ -z "$release" ] && die "release not defined in pkgfile"

    PATH= type build >/dev/null || die "build() not found in pkgfile."
    pkg_deps
    pkgfile=1
}

pkg_deps() {
    for dep in $depends; do
        pkg_list "$dep" >/dev/null || miss="$miss $dep"
    done

    [ -n "$miss" ] && die "missing dependencies:$miss"
}

pkg_get() {
    mkdir -p build || die "couldn't create build dir"
    mkdir -p "$PKG_ROOT/$tar_dir/$name" || die "couldn't create cache dir"

    for src in $source; do
        if is_remote "$src"; then
            [ -f "$PKG_ROOT/$tar_dir/$name/${src##*/}" ] && {
                log "found cached $src"
                continue
            }

            log "downloading $src"
            wget -P "$PKG_ROOT/$tar_dir/$name" -- "$src" ||
                die "failed to download $src"
        else
            [ -f "$src" ] && continue
            die "source file $src not found"
        fi
    done
}

pkg_verify() {
    pkg_checksum build/.checksum

    diff .checksum build/.checksum ||
        die "checksum of sources does not match checksum of package" \
            "run 'pkg checksum' to update checksums"
}

pkg_manifest() {
    cd "$og_pwd/build/pkg" >/dev/null

    printf '%s\n' "$version" > "$db_dir/$name/version"

    _() { find . -mindepth 1 "$@" | sed 's/^\.//'; }
    _ -not -type d  > ../../.manifest

    printf '%s\n' "/$db_dir/$name/manifest" >> ../../.manifest

    _ -type d | sort -r >> ../../.manifest
}

pkg_extract() {
    cd build >/dev/null || die "can't access build dir"
    mkdir -p src "pkg/$db_dir/$name"

    for pkg in $source; do
        file_name=${pkg##*/}

        case $pkg in
            *.tar|*.tar.gz|*.tar.xz|*.tar.bz2|*.tar.lzma|\
            *.tar.lz|*.txz|*.tgz|*.tbz2)
                tar xaf "$PKG_ROOT/$tar_dir/$name/$file_name" \
                    -C src --strip-components 1 ||
                    die "couldn't extract $file_name"
            ;;

            *.zip)
                log "warn: You may need to cd into zip directory."
                unzip -qd src "$PKG_ROOT/$tar_dir/$name/$file_name" ||
                    die "couldn't extract $file_name"
            ;;

            *)  cp -f "../$file_name" src ;;
        esac
    done

    _(){ [ "$1" = "src/*" ] && die "no source files found";}; _ src/*
}

pkg_build() {
    cd src >/dev/null || die "can't access src dir."
    BUILD=$og_pwd/build/pkg

    set -e
    build || die "failed to build $name-$version"
    set +e

    pkg_manifest
    cd "$og_pwd" >/dev/null

    cp .manifest "build/pkg/$db_dir/$name/manifest"
    tar pcvf "${name}_$version-$release.tar.gz" \
        -C build/pkg . >/dev/null || die "failed to create package"

    log "successfuly built $name"
    log "package is at ${name}_$version-$release.tar.gz"
}

pkg_add() {
    name=${1%_*.tar.gz*}

    [ -f "$1" ] || die "file not found"
    [ -z "${1##*.tar.??}" ] || die "add requires a tarball"
    [ -n "$PKG_ROOT" ] && mkdir -p "$PKG_ROOT"
    [ -f "$PKG_ROOT/$db_dir/$name/manifest" ] && pkg_delete "$name"

    tar pxvf "$1" -C "$PKG_ROOT/" || die "couldn't extract $name"
    log "successfuly installed $name to $PKG_ROOT/"
}

pkg_delete() {
    pkg_db="$PKG_ROOT/$db_dir/$1/manifest"

    [ -z "$1" ] && die "delete needs an argument"
    [ -f "$pkg_db" ] || die "package not installed"

    while read -r line; do
        line=$PKG_ROOT/$line

        if [ -d "$line" ]; then
            find "$line" -mindepth 1 | read -r || rmdir "$line"
        else
            rm -- "$line"
        fi
    done < "$pkg_db"

    log "removed $1"
}

pkg_list() {
    cd "$PKG_ROOT/$db_dir" >/dev/null || die "can't access database"

    _() { read -r v < "$1/version"; printf '%s\n' "$1 $v"; }
    [ -n "$1" ] && ! [ -f "$1/version" ] && return 1

    for pkg in *; do
        [ -f "$1/version" ] && { _ "$1"; break; }
        [ -f "$pkg/version" ] || return 1
        _ "$pkg"
    done

    cd - >/dev/null
}

pkg_checksum() {
    for src in $source; do
        if is_remote "$src"; then
            files="$files $PKG_ROOT/$tar_dir/$name/${src##*/}"
        else
            files="$files $src"
        fi
    done

    sha256sum -- $files | sed "s|${PKG_ROOT:-/}||" > "$1" ||
        die "failed to generate checksums"
    log "Saved checksum to $1"
}

is_remote() {
    [ -z "${src##*://*}" ] && return 0
    return 1
}

clean() {
    [ "$pkgfile" = 1 ] || return
    [ -f "$og_pwd/pkgfile" ] || return
    rm -rf "$og_pwd/build"
}

die() {
    printf '\e[31m!>\e[m %s\n' "$@" >&2
    exit 1
}

log() {
    printf '\e[32m=>\e[m %s\n' "$1"
}

args() {
    [ -z "$in_fakeroot" ] && in_fakeroot=1 exec fakeroot -- pkg "$@"

    case $1 in
        a*) pkg_add "$2" ;;

        b*)
            pkgfile_read

            [ -f .checksum ] || die "checksum not found, run 'pkg checksum'"

            pkg_get
            pkg_verify
            pkg_extract
            pkg_build
        ;;

        c*)
            pkgfile_read
            pkg_get
            pkg_checksum .checksum
        ;;

        d*) pkg_delete "$2" ;;
        l*) pkg_list "$2" ;;
        -v) printf '%s\n' "pkg 0.1.0" ;;

        *)  printf '%s' "\
usage:
  - pkg [a]dd pkg.tar.gz
  - pkg [b]uild
  - pkg [c]hecksum
  - pkg [d]el pkg
  - pkg [l]ist
"
        ;;
    esac
}

main() {
    type fakeroot >/dev/null || die "fakeroot not installed"

    og_pwd=$PWD
    db_dir=var/db/pkg
    tar_dir=var/cache/pkg

    trap clean EXIT INT
    clean

    args "$@"
}

main "$@"
